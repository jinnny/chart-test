<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
<!--  <script src="https://d3js.org/d3.v4.min.js"></script>-->
  <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
  <script src="https://d3js.org/d3.v6.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <link rel="stylesheet" href="../assets/style/default.css">
  <style>
      .chart-text-group, .chart-line-group {
          transform: rotate(-101deg) translate(12px,-11px);
          transform-origin: center;
      }
      .chart-area {
          display: flex;
          flex-direction: column;
      }
  </style>
</head>
<body>
  <div class="chart-area"></div>
<script>
  // progress 그리기
  //my 우리집 사용량 , neighbor 이웃집 사용량, maxValue 최대 사용량
  function drawCircle({ my, neighbor, maxValue }) {
    const data = [0];
    const width = 300,
      height = 150,
      radius = 134,
      smallRadius = 120,
      semiCircleSvg = d3.select('.chart-area').append('svg')
        .attr('width', width).attr('height', height)
        .attr('class','semiCircleChart')

    const g = semiCircleSvg.append('g')
      .attr('transform', `translate(${width/2},${height/1.1})`);
    const semiCircleDefs = semiCircleSvg.append('defs')
    const semiCircleFilter = semiCircleDefs.append('filter')

    const filterShadow = semiCircleFilter
      .attr('id', 'shadow')
      .attr('x','-50%').attr('y','-50%')
      .attr('width','200%').attr('height', '200%')
      .attr('color-interpolation-filters','sRGB')

    filterShadow.append('feGaussianBlur')
      .attr('in', 'SourceAlpha')
      .attr('stdDeviation', 10)
      .attr('result', 'blur')
    filterShadow.append('feDropShadow')
      .attr('dx',0).attr('dy', 3)
      .attr('flood-color', '#333')
      .attr('stdDeviation', 4)
      .attr('flood-opacity', 0.2)
    filterShadow.append('feComponentTransfer').append('feFuncA')
      .attr('type','linear')
      .attr('slope', '0.2')

    const feMerge = filterShadow.append('feMerge');
    feMerge.append('feMergeNode')
      .attr('in', 'offsetBlur')
    feMerge.append('feMergeNode')
      .attr('in', 'SourceGraphic');

    const filterBg = semiCircleDefs.append('filter')
      .attr('x',0)
      .attr('y',0)
      .attr('width',1)
      .attr('height',1)
      .attr('id','solid')

    filterBg.append('feFlood')
      .attr('flood-color','#ccc')
      .attr('result', 'bg')

    const feMergeBg = filterBg.append('feMerge');
    feMergeBg.append('feMergeNode')
      .attr('in', 'bg')
    feMergeBg.append('feMergeNode')
      .attr('in', 'SourceGraphic');

    const textArea =
      semiCircleSvg.append('rect')
        .attr('transform', `translate(${(width-120)/2},${height/1.6})`)
        .attr('width',120).attr('height', 50)
        .attr('x',0).attr('y',0)
        .attr('fill','#e7e7e7')
        .attr('stroke-width','8')
        .attr('stroke','#e7e7e7')
        .attr('stroke-linecap','round')
        .attr('stroke-linejoin','round');

    const text =
      semiCircleSvg.append('text')
        .attr('transform', `translate(${140},${height/1.6})`)
        .attr('font-family', 'NanumSquare')
        .attr('font-size', '16')
        .attr('text-anchor', 'middle')
        .attr('class','circle-percentage')
        .attr('width', 100)
        .attr('fill','black')
        .attr('text-anchor', 'middle')
    text.append('tspan').text('이웃집 평균대비')
      .attr('x', '10').attr('dy', '1.2em')
      .attr('font-size', '13')
    text.append('tspan').data(data)
      .attr('class','text-percentage')
      .attr('fill', 'green')
      .attr('font-size', '23')
      .attr('dy', '1.2em')
      .attr('text-anchor', 'middle')
      .attr('x',10)
      .attr('font-weight', 'bold')
    text.append('tspan').text('')
      .attr('fill','black')
      .attr('font-size', '13')
      .attr('class','text-percentage-text')

    // Generate the pie
    const pie = d3.pie();

    //내집 영역 라인
    const arc = d3.arc().innerRadius(radius -10).outerRadius(radius).startAngle(-Math.PI / 2).endAngle(Math.PI / 2);
    //내집 데이터 그래프 라인
    const arcLine = d3.arc().innerRadius(radius - 10 + 5).outerRadius(radius - 10 + 5).startAngle(-Math.PI / 2).endAngle(Math.PI / 2);

    //이웃집 영역 라인
    const neighborArc = d3.arc().innerRadius(smallRadius - 10).outerRadius(smallRadius).startAngle(-Math.PI / 2).endAngle(Math.PI / 2);
    //이웃집 데이터 그래프 라인
    const neighborArcLine = d3.arc().innerRadius(smallRadius - 10 + 5).outerRadius(smallRadius - 10 + 5).startAngle(-Math.PI / 2).endAngle(Math.PI / 2);

    //arc 그룹
    var arcs = g.selectAll('arc').data(pie(data)).enter().append('g')
      .attr('class', 'arc')

    //내집 영역 path 그리기
    arcs.append('path')
      .attr('fill', '#eee')
      .attr('d', arc);
    //이웃집 영역 path 그리기
    arcs.append('path')
      .attr('fill', '#eee')
      .attr('d', neighborArc);

    //이웃 데이터 그래프
    g.append('path')
      .attr('fill','none')
      .attr('d', neighborArcLine)
      .attr('stroke-width','8')
      .attr('stroke','#944ce9')
      .attr('stroke-linecap','round')
      .attr('stroke-linejoin','round')
      .attr('class','neighborGraphic')

    //내집 데이터 그래프
    g.append('path')
      .attr('fill','none')
      .attr('d', arcLine)
      .attr('stroke-width','8')
      .attr('stroke','green')
      .attr('stroke-linecap','round')
      .attr('stroke-linejoin','round')
      .attr('class','myHomeGraphic')

    const chart = d3.select('.semiCircleChart');
    const center = parseInt(chart.style('height')) / 2;

    function drawNumbers(radius) {
      //눈금표시
      const pos = radius * 0.85;
      const chartLineGroup = semiCircleSvg.append('g')
        .attr('class', 'chart-line-group')

      for (let num = 1; num < 20; num++) {
        const deg = 10 * num;
        const x = pos * Math.cos(Math.PI * (deg - 90) / 182.5);
        const y = pos * Math.sin(Math.PI * (deg - 90) / 182.5);
        const cx = x + center;
        const cy = y + center;
        if(num%2 === 0) {
          const chartText = chartLineGroup.append('line')
          chartText.attr('x1', cx).attr('x2', cx)
            .attr('y1', cy).attr('y2', cy+4)
            .attr( 'transform', `rotate(${deg},${cx},${cy})` )
            .attr('class', 'short-line')
            .attr('stroke','#ccc')
          // .attr('stroke','url(#gradient-1)')
        }else {
          const chartLine = chartLineGroup.append('line')
          chartLine.attr('x1', cx).attr('x2', cx)
            .attr('y1', cy).attr('y2', cy+10)
            .attr( 'transform', `rotate(${deg},${cx},${cy})`)
            .attr('class', 'number')
            .attr('stroke','#ccc')
        }
      }
    }

    drawNumbers(smallRadius + 8);
    // const group = semiCircleSvg.append('g').attr('transform', `translate(${width/2},${height/1.1})`)
    g.append('circle')
      .attr('class', 'neighborPoint')
      .attr('cx', -115).attr('cy', 0).attr('r', 7)
      .attr('fill','#944ce9')
      .attr('stroke', '#fff')
      .attr('stroke-width', 3)
    // 시작과 끝 동그라미
    g.append('circle')
      .attr('class', 'myHomePoint')
      .attr('cx', -130).attr('cy', 0).attr('r', 7)
      .attr('fill','green')
      .attr('stroke', '#fff')
      .attr('stroke-width', 3)

    const max = maxValue
    const min = 0
    const maxPerMyRatio = ((my >= max ? max: my) / max * 100).toFixed(2)
    const maxPerNeighborRatio = ((neighbor >= max ? max: neighbor) / max * 100).toFixed(2)
    const myPerNeighborRatio = parseInt(my/neighbor*100)

    const neighborOutline = document.querySelector('.neighborGraphic');
    const neighborOutlineT = d3.select('.neighborGraphic');
    const neighborLineL = neighborOutline.getTotalLength() || 966.672;
    neighborOutline.style.strokeDasharray = neighborLineL;
    neighborOutline.style.strokeDashoffset = neighborLineL;
    const neighborOneUnit = neighborLineL/200;
    const neighborToOffset = (neighborLineL - neighborOneUnit * maxPerNeighborRatio).toFixed(2);
    neighborOutlineT.transition().duration(1300).ease(d3.easeQuadInOut).style('stroke-dashoffset', neighborToOffset)

    const neighborRotateDeg = maxPerNeighborRatio * 1.8 >= 180 ? 180 : maxPerNeighborRatio * 1.8
    const neighborPoint = d3.select('.neighborPoint')
    console.log(neighborRotateDeg)
    neighborPoint.transition().duration(1300).ease(d3.easeQuadInOut).attr('transform', `rotate(${neighborRotateDeg})`)

    const myOutline = document.querySelector('.myHomeGraphic');
    const myOutlineT = d3.select('.myHomeGraphic');
    const myLineL = myOutline.getTotalLength() || 966.672;
    myOutline.style.strokeDasharray = myLineL;
    myOutline.style.strokeDashoffset = myLineL;
    const myOneUnit = myLineL/200;
    const myToOffset = (myLineL - myOneUnit * maxPerMyRatio).toFixed(2);
    myOutlineT.transition().duration(1300).delay(500).ease(d3.easeQuadInOut).style('stroke-dashoffset', myToOffset)

    const myRotateDeg = maxPerMyRatio * 1.8 >= 180 ? 180 : maxPerMyRatio * 1.8
    const myHomePoint = d3.select('.myHomePoint')
    // myHomePoint.attr('transform', `rotate(${myRotateDeg}deg)`)
    myHomePoint.transition().duration(1300).delay(500).ease(d3.easeQuadInOut).attr('transform', `rotate(${myRotateDeg})`)

    // 가운데 수치표시
    function countText(time,progress){
      const textPercentageContainer = d3.select('.text-percentage');
      const textPercentageText = d3.select('.text-percentage-text');
      let i = 0;
      const intervalTime = Math.abs(time / progress)
      if(progress > 100) {
        const timerID = setInterval(function () {
          i++;
          textPercentageContainer.html(`${i}%`);
          textPercentageText.html(' 초과')
          if (i === Math.abs(progress-100)) clearInterval(timerID);
        }, intervalTime);
      }else if(progress === 100) {
        const timerID = setInterval(function () {
          i++;
          textPercentageContainer.html(`${i}%`);
          textPercentageText.html('')
          if (i === Math.abs(progress)) clearInterval(timerID);
        }, intervalTime);
      }else {
        const timerID = setInterval(function () {
          i++;
          textPercentageContainer.html(`${i}%`);
          textPercentageText.html(' 절약')
          if (i === Math.abs(progress)) clearInterval(timerID);
        }, intervalTime);
      }
    }
    countText(1300,myPerNeighborRatio);
  }

  //my 우리집 사용량 , neighbor 이웃집 사용량, maxValue 최대 사용량
  drawCircle({ my: 1500, neighbor: 15000, maxValue: 150000 })

  //my 우리집 사용량 , neighbor 이웃집 사용량, maxValue 최대 사용량
  function setPosition({ my, neighbor, maxValue }) {
    // linear chart
    const linearWidth = 300
    const linearHeight = 100
    const leftSpace = 25
    const linearBarHeight = 2
    const linearBarBorder = 15
    const svgLinear = d3.select('.chart-area').append('svg')
      .attr('width', linearWidth).attr('height', linearHeight)
      .attr('viewBox', `0 0 ${linearWidth} ${linearHeight}`)

    const defs = svgLinear.append('defs')
    const linear = defs.append('linearGradient').attr('id', 'gradientStroke')
    linear.append('stop')
      .attr('stop-color', '#00d5bd')
      .attr('offset', '0')
    linear.append('stop')
      .attr('stop-color', 'yellow')
      .attr('offset', '0.5')
    linear.append('stop')
      .attr('stop-color', 'red')
      .attr('offset', '1');

    const color = 'url(#gradientStroke)'
    const filterShadow = defs.append('filter')
      .attr('id', 'shadow')
      .attr('height', '130%')
    filterShadow.append('feGaussianBlur')
      .attr('in', 'SourceAlpha')
      .attr('stdDeviation', 10)
      .attr('result', 'blur')
    filterShadow.append('feDropShadow')
      .attr('dx',0).attr('dy', 2)
      .attr('flood-color', '#ddd')
      .attr('stdDeviation', 10)
    filterShadow.append('feComponentTransfer').append('feFuncA')
      .attr('type','linear')
      .attr('slope', '0.3')

    const feMerge = filterShadow.append('feMerge');
    feMerge.append('feMergeNode')
      .attr('in', 'offsetBlur')
    feMerge.append('feMergeNode')
      .attr('in', 'SourceGraphic');

    svgLinear.append('rect')
      .attr('width', linearWidth-(leftSpace*2)).attr('height', linearBarHeight)
      .attr('stroke-width', linearBarBorder)
      .attr('stroke-linecap','round')
      .attr('stroke-linejoin','round')
      .attr('stroke',color)
      .attr('transform', 'translate(' + (linearWidth-(linearWidth-(leftSpace*2)))/2 + ',' + linearHeight / 2 + ')')

    svgLinear.append('text').text('최저0원')
      .attr('transform', `translate(${leftSpace},${linearHeight/2+(linearBarBorder*2)})`)
      .attr('font-size', 12)
      .attr('fill','#bbb')
    svgLinear.append('text').text('최대1500,00원')
      .attr('transform', `translate(${linearWidth-leftSpace-74},${linearHeight/2+(linearBarBorder*2)})`)
      .attr('font-size', 12)
      .attr('fill','#bbb')

    // 내집 마커그룹 그리기
    const gMy = svgLinear.append('g')
      .attr('transform', `translate(${leftSpace},${linearHeight/2-linearBarBorder})`)
      .attr('class','myMarkerGroup')
    gMy.append('circle')
      .attr('class', 'neighborPoint')
      .attr('cx', 0).attr('cy', 0).attr('r', 7)
      .attr('fill','#944ce9')
      .attr('stroke', '#fff')
      .attr('stroke-width', 5)
    gMy.append('line')
      .attr('x1', 1).attr('x2', 1)
      .attr('y1', 1).attr('y2', 8)
      .attr('transform', 'translate(0,6)')
      .style('stroke', 'white')

    // 이웃집 마커그룹 그리기
    const gNeighbor = svgLinear.append('g')
      .attr('transform', `translate(${leftSpace},${linearHeight/2-linearBarBorder})`)
      .attr('class', 'neighborMarkerGroup')
    gNeighbor.append('circle')
      .attr('class', 'myPoint')
      .attr('cx', 0).attr('cy', 0).attr('r', 7)
      .attr('fill','green')
      .attr('stroke', '#fff')
      .attr('stroke-width', 5)
    gNeighbor.append('line')
      .attr('x1', 1).attr('x2', 1)
      .attr('y1', 1).attr('y2', 8)
      .attr('transform', 'translate(0,6)')
      .style('stroke', 'white')

    const myMarkerGroup = d3.select('.myMarkerGroup');
    const neighborMarkerGroup = d3.select('.neighborMarkerGroup');

    const max = maxValue
    const min = 0
    const minPosition = 25
    const maxPosition = linearWidth - minPosition
    const convert = d3.scaleLinear().domain([min,max]).range([minPosition, maxPosition]);
    const myMarkerPosition = parseInt(convert(my))
    const neighborMarkerPosition = parseInt(convert(neighbor))
    myMarkerGroup.transition().duration(1300).delay(500).ease(d3.easeQuadInOut).attr('transform', `translate(${myMarkerPosition},${linearHeight/2-linearBarBorder})`)
    neighborMarkerGroup.transition().duration(1300).ease(d3.easeQuadInOut).attr('transform', `translate(${neighborMarkerPosition},${linearHeight/2-linearBarBorder})`)
  }

  //my 우리집 사용량 , neighbor 이웃집 사용량, maxValue 최대 사용량
  setPosition({ my: 10000, neighbor: 20000, maxValue: 150000 })

</script>
</body>
</html>
